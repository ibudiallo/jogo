package jogo

import (
	"encoding/json"
	"fmt"
	"go/format"
	"jogo/jerror"
	"math/rand"
	"reflect"
	"regexp"
	"strings"
)

var GOKeywords = []string{"API", "ASCII", "CPU", "CSS", "DNS", "EOF", "GUID", "HTML", "HTTP",
	"HTTPS", "ID", "IP", "JSON", "LHS", "QPS", "RAM", "RHS", "RPC", "SLA",
	"SMTP", "SSH", "TCP", "TLS", "TTL", "UDP", "UI", "UID", "UUID", "URI",
	"URL", "UTF8", "VM", "XML", "XSRF", "XSS",
}

type Jogo struct {
	container []string
}

type contentType string
type annotType string

const (
	contentJSON  contentType = "json"
	contentXML               = "xml"
	contentError             = "error"
)

const (
	annotJSONType annotType = "json"
	annotXMLType            = "xml"
)

func New() *Jogo {
	return &Jogo{}
}

func (j *Jogo) detectFormat(content string) (contentType, error) {
	str := strings.TrimSpace(content)
	if len(str) < 1 {
		return "", jerror.New("can't detect the format. The file is empty")
	}
	t := str[:1]
	switch t {
	case "{":
		return contentJSON, nil
	case "<":
		return contentXML, nil
	}
	return contentError, jerror.New("invalid content type")
}

func (j *Jogo) Process(content string) error {
	t, err := j.detectFormat(content)
	if err != nil {
		return jerror.Wrap(err, "detect format")
	}
	switch t {
	case contentJSON:
		err = j.processJSON(content)
		if err != nil {
			return jerror.Wrap(err, "process json")
		}
	case contentXML:
		err = j.processXML(content)
		if err != nil {
			return jerror.Wrap(err, "process xml")
		}
	}
	return nil
}

func (j *Jogo) Print() error {
	if len(j.container) == 0 {
		return jerror.New("nothing to print")
	}
	gen := strings.Join(j.container, "\n\n")
	formatedGoStr, err := j.goFmt(gen)
	if err != nil {
		return jerror.Wrap(err, "failed to format")
	}
	fmt.Println(formatedGoStr)
	return nil
}

func (j *Jogo) processJSON(content string) error {
	var i interface{}
	byt := []byte(content)
	err := json.Unmarshal(byt, &i)
	if err != nil {
		return jerror.Wrap(err, "unmarshal json")
	}
	var (
		generated string
		out       []string
	)
	uniqName := getUniqueName()
	generated = "type AutoGenerated struct {" + uniqName + "}"
	switch reflect.TypeOf(i).Kind() {
	case reflect.Map:
		m := i.(map[string]interface{})
		for k, v := range m {
			line := j.jprocessLine(k, v, 1)
			out = append(out, line)
		}
	}
	generated = strings.Replace(
		generated,
		uniqName,
		"\n"+strings.Join(out, "\n")+"\n",
		-1,
	)
	j.container = append(j.container, generated)
	return nil
}

func (j *Jogo) processXML(content string) error {
	return jerror.New("xml not implemented yet")
}

func (j *Jogo) jprocessLine(key string, value interface{}, depth int) string {
	name := formatName(key)
	t := "string"
	annot := getAnnotations(key, annotJSONType, true)
	tt := reflect.TypeOf(value).Kind()
	switch tt {
	case reflect.String:
		return name + " string " + annot
	case reflect.Float64:
		return name + " float64 " + annot
	case reflect.Bool:
		return name + " bool " + annot
	case reflect.Slice:
		val := reflect.ValueOf(value)
		var t string
		for i := 0; i < val.Len(); i++ {
			t = reflect.TypeOf(val.Index(i).Interface()).Kind().String()
			break
		}
		switch t {
		case "float64", "string", "bool":
			return name + " []" + t + " " + annot
		case "map":
			face := val.Index(0).Interface()
			v := face.(map[string]interface{})
			sing := singular(name)
			if len(v) == 0 {
				return name + " []interface{} " + annot
			}
			_ = j.jprocessMap(key, v, depth+1)
			fmt.Printf("hey %+v\n", v)
			return name + " []" + sing + " " + annot
		}
		return name + " interface{}" + " " + annot
	case reflect.Map:
	}
	out := name + " " + t + " " + getAnnotations(key, annotJSONType, true)
	return out
}

func (j *Jogo) jprocessMap(key string, m map[string]interface{}, depth int) string {
	name := formatName(key)
	uniq := getUniqueName()
	out := "type " + singular(name) + " struct {\n" + uniq + "\n}"
	var o []string
	for k, v := range m {
		mAnnot := getAnnotations(k, "json", true)
		s := formatName(k) + " string " + mAnnot
		o = append(o, s)
		if v != nil {

		}
	}
	out = strings.Replace(out, uniq, strings.Join(o, "\n"), -1)
	j.container = append(j.container, out)
	return out
}

func (j *Jogo) goFmt(content string) (string, error) {
	byt, err := format.Source([]byte(content))
	if err != nil {
		return "", jerror.Wrap(err, "gofmt code")
	}
	return string(byt), nil
}

func formatName(name string) string {
	if name[:1] == "_" {
		name = name[1:]
	}
	strCap := strings.ToUpper(name[:1]) + name[1:]
	strCap = regexp.MustCompile("_\\S").ReplaceAllStringFunc(strCap,
		func(s string) string {
			return strings.ToUpper(s[1:])
		})
	strCap = regexp.MustCompile("[A-Z][a-z]+").ReplaceAllStringFunc(strCap,
		func(s string) string {
			upStr := strings.ToUpper(s)
			if stringInSlice(upStr, GOKeywords) {
				return strings.ToUpper(s)
			}
			return s
		})
	return strCap
}

func stringInSlice(a string, list []string) bool {
	for _, b := range list {
		if b == a {
			return true
		}
	}
	return false
}

func singular(plural string) string {
	l := len(plural)
	ies := plural[l-3:]
	xes := ies
	ses := ies
	es := plural[l-2:]
	s := plural[l-1:]
	if ies == "ies" {
		return plural[:l-4] + "y"
	}
	if xes == "xes" {
		return plural[:l-4] + "x"
	}
	if ses == "ses" {
		return plural[:l-4] + "s"
	}
	if es == "es" {
		return plural[:l-3] + "e"
	}
	if s == "s" {
		return plural[:l-1]
	}
	return plural
}

func getUniqueName() string {
	return fmt.Sprintf("uniq-%d", rand.Intn(10000000))
}

func getAnnotations(key string, t annotType, omit bool) string {
	var o string
	if omit {
		o = ",omitempty"
	}
	switch t {
	case annotXMLType:
		return "`xml:\"" + key + o + "\"`"
	case annotJSONType:
		return "`json:\"" + key + o + "\"`"
	}
	return ""
}
