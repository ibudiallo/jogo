(function ( window ) {
let Jogo = {
	goKeys: ["API", "ASCII", "CPU", "CSS", "DNS", "EOF", "GUID", "HTML", "HTTP", 
			"HTTPS", "ID", "IP", "JSON", "LHS", "QPS", "RAM", "RHS", "RPC", "SLA", 
			"SMTP", "SSH", "TCP", "TLS", "TTL", "UDP", "UI", "UID", "UUID", "URI", 
			"URL", "UTF8", "VM", "XML", "XSRF", "XSS"],
	obj: null,
	container: [],
	tabChar: "\t",
	init: function( opts ) {

	},
	convert: function(varname,jsonStr){
		this.container = [];
		var obj = null,
		name = varname.replace(/[^\w]+/g,'').trim();
		if (name.length < 2){
			name = "AutoGenerated";
		}
		try {
			obj = JSON.parse(jsonStr);
		}catch(e) {
			alert("invalid json: "+e);
			return false;
		}
		this.process(obj, name)
		return this.getContainers();
		for (let i = 0, l = containers.length; i < l; i++) {
			let div = document.createElement("div");
			div.id = "go-struct-"+i;
			div.className = "go-struct";
			div.innerHTML = containers[i];
			this.box.appendChild(div);
		}
	},

	process: function(obj,name) {
		var contentName = "Content-"+Math.random(),
			strOut = ("type {} struct {\n{"+contentName+"}\n}").replace("{}",name),
			hash = this.getObjHash(obj);
		var data = this.processObject(obj,name, 1);
		strOut = strOut.replace("{"+contentName+"}",data.join("\n"));
		let total = this.addToContainer(name, strOut, hash);
	},

	processObject : function(obj,key,depth) {
		let content = [];
		for (let key in obj) {
			let elem = obj[key];
			let type = this.getType(elem);
			let out = "";
			let keyName = this.formatName(key);
			if (type === "array") {
				out = this.processArray(elem,key,depth);
				content.push(out);
				continue;
			}
			if (type === "interface{}") {
				let tabs = this.getTabs(depth);
				if (this.isEmptyObj(elem)) {
					content.push(this.getTabs(depth)+keyName +" interface{} " + this.annotate(key));
					continue;
				}
				let objContentName = "Content-"+Math.random();
				let objOut = tabs+keyName+ " struct {\n"+objContentName+"\n"+tabs+"} " + this.annotate(key);
				let data = this.processObject(elem,key,depth+1);
				out = objOut.replace(objContentName,data.join("\n"));
				content.push(out);
				continue;
			}
			out += this.getTabs(depth) + keyName + " "+ type + " "+this.annotate(key);
			content.push(out) 
		}
		return content;
	},

	processArray : function(arr,key,depth) {
		if (this.getType(arr) !== "array") {
			return this.getTabs(depth)+this.getType(arr);
		}
		let keyName = this.formatName(key)
		let annot = this.annotate(key);
		if (arr.length < 1) {
			return this.getTabs(depth)+keyName +" []interface{} " + annot
		}
		let first = arr[0];
		let t = this.getType(first);
		if (t === "array") {
			return this.processArrayList(first,key,depth);
		}
		if (t === "interface{}"){
			return this.processArrayObject(first, key, depth);
		}
		return this.getTabs(depth)+ keyName + " []"+t+ " " +annot;
	},

	processArrayList: function(list,key,depth){
		let keyName = this.formatName(key);
		let annot = this.annotate(key);
		if (list.length === 0) {
			return  this.getTabs(depth)+ keyName+" []interface{} "+ annot;
		}
		let cName = "Content-"+Math.random();
		let out = this.getTabs(depth)+keyName +" []struct {\n"+cName+"\n"+this.getTabs(depth)+"} " + annot;
		let data = this.processArray(list[0],"",depth+1);
		out = out.replace(cName,data);
		return out;
	},

	processArrayObject: function(obj, key, depth) {
		let keyName = this.formatName(key);
		let annot = this.annotate(key);
		let tabs = this.getTabs(depth);
		let objContentName = "Content-"+Math.random();
		let data = this.processObject(obj,key, 1);
		let out = "";
		if (data.length < 1) {
			return this.getTabs(depth)+keyName +" []interface{} " + annot
		}
		out = "type "+this.singular(keyName) +" struct {\n"+objContentName+"\n}";
		out = out.replace(objContentName,data.join("\n"));
		//out = this.groupFormat(out);
		let hash = this.getObjHash(obj);
		let total = this.addToContainer(keyName, out, hash);
		let append = "";
		if (total > 0) {
			// TODO
			//append = total;
		}
		return tabs+keyName+ " []"+this.singular(keyName)+append +" "+ this.annotate(key);
	},

	getTabs: function(count) {
		let tabs = "";
		for (let i = 0; i < count; i++) {
				tabs += Jogo.tabChar;
		}
		return tabs;
	},

	getType: function(obj) {
		let t = typeof obj
		switch(t){
		case "string":
			return "string";
		case "number":
			if (obj === Math.floor(obj)) {
				return "int"
			}
			return "float32";
		case "boolean":
			return "bool";
		}
		if (this.isArray(obj)) {
			return "array";
		}
		return "interface{}";
	},

	isArray: function(obj) {
		return Array.isArray(obj);
	},

	isEmptyObj: function(obj) {
		let count = 0;
		for (let i in obj){
			if (obj.hasOwnProperty(i)) {
				count++;
				break;
			}
		}
		return count === 0;
	},

	annotate: function(name){
		return '`json:"{}"`'.replace("{}",name+",omitempty");
	},

	formatName: function(name){
		let cap = name[0].toUpperCase()+ name.substr(1);
		cap = cap.replace(/_\S/g,function(a){
			return a[1].toUpperCase();
		});
		return cap.replace(/(^|[^a-zA-Z])([a-z]+)/g, function(unused, sep, frag) {
			if (Jogo.goKeys.indexOf(frag.toUpperCase()) >= 0){
				return sep + frag.toUpperCase();
			}
			return sep + frag[0].toUpperCase() + frag.substr(1).toLowerCase();
		}).replace(/([A-Z])([a-z]+)/g, function(unused, sep, frag){
			if (Jogo.goKeys.indexOf(sep + frag.toUpperCase()) >= 0) {
				return (sep + frag).toUpperCase();
			}
			return sep + frag;
		});
	},
	// TODO: Not done yet
	groupFormat: function(group) {
		let lines = group.split('\n');
		let outLines = [];
		let start = 0;
		let isProcess = false;
		let lengths = {
			left: 0,
			mid: 0,
			right: 0,
		};
		let depth = 0;
		for (let i = 0,l = lines.length;i<l;i++) {
			let line = lines[i].trim();
			let words = line.split(/\s/);
			if (words[words.length-1] === "{"){
				outLines.push(lines[i])
				if (i > 0) {
					let out = this._formatRange(lines,start,i,lengths,depth);
					for (let j = 0;j < out.length; j++) {
						outLines.push(out[j])
					}
				}
				start = i+1;
				isProcess = true;
				depth++;
			}else if (words[words.length-1] === "}" || words[0] === "}"){
				// process til here
				let out = this._formatRange(lines,start,i,lengths,depth);
				for (let j = 0;j < out.length; j++) {
					outLines.push(out[j])
				}
				isProcess = false;
				depth--;
				outLines.push(lines[i])
			} else if (isProcess) {
				if (words.length < 3) {
					outLines.push(lines[i]);
					continue;
				}
				let k = 0;
				while(words[k] === "") {
					k++;
				}
				if (words[k].length > lengths.left ){
					lengths.left = words[k].length;
				}
				if (words[k+1].length > lengths.left ){
					lengths.mid = words[k+1].length;
				}
				if (words[k+2].length > lengths.left ){
					lengths.right = words[k+2].length;
				}
			}
		}
		return outLines.join("\n")
	},

	_formatRange : function(group,from,to,pads,depth){
		let out = [];
		for (let i = from, l = to;i<l;i++) {
			let line = group[i].trim();
			let words = line.split(/\s/);
			if(words.length < 3) {
				out.push(group[i]);
				continue;
			}
			let str = this.getTabs(depth) +
				words[0].padEnd(pads.left +1) +
				words[1].padEnd(pads.mid +1) +
				words[2].padEnd(pads.right +1);
			out.push(str);
		}
		return out;
	},

	singular: function(name) {
		var ies = name.substr(-3);
		var xes = ies;
		var ses = ies;
		var es = name.substr(-2);
		var s = name.substr(-1);
		if (ies === "ies") {
			return name.substr(0,name.length-3) + "y";
		}
		if (ies === "xes") {
			return name.substr(0,name.length-3) + "x";
		}
		if (ses === "ses") {
			return name.substr(0,name.length-3) + "s";
		}
		if (es === "es") {
			return name.substr(0,name.length-2) + "e";
		}
		if (s === "s") {
			return name.substr(0,name.length-1);
		}
		return name;
	},

	getObjHash: function(obj) {
		let arr = [];
		for (let i in obj) {
			arr.push(i)
		}
		let str = JSON.stringify(arr);
		return this.hash(str);
	},

	hash: function (str) {
		let hash = 5381,
		i = str.length;
		while(i) {
			hash = (hash * 33) ^ str.charCodeAt(--i);
		}
		/* JavaScript does bitwise operations (like XOR, above) on 32-bit signed
		* integers. Since we want the results to be always positive, convert the
		* signed int to an unsigned by doing an unsigned bitshift. */
		return hash >>> 0;
	},

	addToContainer: function(name, str,hash) {
		let count = 0;
		for (let i = 0, l = this.container.length; i<l;i++) {
			if (this.container[i].name === name) {
				if (this.container[i].hash === hash){
					return 0;
				}
				count++;
			}
		}
		var a = this.groupFormat(str);
		this.container.push({name:name,content:str,hash});
		return count;
	},

	getContainers : function() {
		let c = [];
		for (let i = 0, l = this.container.length; i < l;i++) {
			c.push(this.container[i].content);
		}
		return c;
	},
};

if ( typeof define === "function" && define.amd ) {
	define(function() { return Jogo; });
// Sizzle requires that there be a global window in Common-JS like environments
} else if ( typeof module !== "undefined" && module.exports ) {
	module.exports = Jogo;
} else {
	window.Jogo = Jogo;
}

})( window );
